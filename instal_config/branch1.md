[< К содержанию](/README.md)

# Ветвление

Это возможность работать над разными версиями проекта: вместо одного списка с упорядоченными коммитами история будет расходиться в определённых точках.   
Каждая ветвь содержит легковесный указатель HEAD на последний коммит, что позволяет без лишних затрат создать много веток.   
Ветка по умолчанию называется `master/main`, но лучше назвать её в соответствии с разрабатываемой в ней функциональностью.

Итак, есть общий указатель HEAD и HEAD для каждой ветки. 
Переключение между ветками предполагает только перемещение HEAD в HEAD соответствующей ветки.

![ветка](./assets/branch2.png)

Команды:

* git branch <имя ветки> — создаёт новую ветку с HEAD, указывающим на HEAD. Если не передать аргумент <имя ветки>, то команда выведет список всех локальных веток;  
* git checkout <имя ветки> — переключается на эту ветку. Можно передать опцию -b, чтобы создать новую ветку перед переключением;  
* git branch -d <имя ветки> — удаляет ветку.  

Локальный и удалённый репозитории могут иметь немало ветвей, поэтому когда вы отслеживаете удалённый репозиторий — отслеживается удалённая ветка (`git clone` привязывает вашу ветку `master` к ветке `origin/master` удалённого репозитория).

Привязка к удалённой ветке:

* *`git branch -u <имя удалённого репозитория>/<удалённая ветка>`* — привязывает текущую ветку к указанной удалённой ветке;  
* *`git checkout --track <имя удалённого репозитория>/<удалённая ветка>`* — аналог предыдущей команды;  
* *`git checkout -b <ветка> <имя удалённого репозитория>/<удалённая ветка>`* — создаёт новую локальную ветку и начинает отслеживать удалённую;  
* *`git branch --vv`* — показывает локальные и отслеживаемые удалённые ветки;  
* *`git checkout <удалённая ветка>`* — создаёт локальную ветку с таким же именем, как у удалённой, и начинает её отслеживать.  

В общем, `git checkout` связан с изменением места, на которое указывает HEAD ветки, что похоже на то, как `git reset` перемещает общий HEAD.

## Прятки и чистка  

Есть одна тонкость — при переключении веток Git требует, чтобы рабочее состояние было чистым, то есть все изменения в отслеживаемых файлах должны быть зафиксированы.
Это не совсем так. При некоторых обстоятельствах Git может автоматически перенести незафиксированное изменение в другую ветку.
Однако порой у вас есть незавершённые изменения, которые нельзя фиксировать. В такой ситуации их можно сохранить и «спрятать» с помощью команды *`git stash`*.   
Чтобы вернуть изменения, используйте *`git stash apply`*.

Возможно, вместо этого вы захотите стереть все внесённые изменения. 

В таком случае используйте команду *`git cleanё`*. 

Опция `-d` также удалит неотслеживаемые файлы. 

Совет: добавьте опцию `-n`, чтобы увидеть, что произойдёт при запуске *`git clean`* без непосредственного использования.

## Слияние
Ветку, в которую мы хотим слить изменения, будем называть основной, а ветку, из которой мы будем их сливать, — тематической.

Слиние включает в себя создание нового коммита, который основан на общем коммите-предке двух ветвей и указывает на оба HEAD в качестве предыдущих коммитов.   
Для слияния мы переходим на основную ветку и используем команду *`git merge <тематическая ветка>`*.

![Слияние](/assets/merge2.png)

Если обе ветви меняют одну и ту же часть файла, то возникает конфликт слияния — ситуация, 
в которой Git не знает, какую версию файла сохранить, поэтому разрешать конфликт нужно собственноручно. 
Чтобы увидеть конфликтующие файлы, используйте *`git status`*.

После разрешения всех конфликтов можно использовать *`git commit`* для завершения слияния.

## Перемещение

Вместо совмещения двух ветвей коммитом слияния, 
перемещение заново воспроизводит коммиты тематической ветки в виде набора новых коммитов базовой ветки, что выливается в более чистую историю коммитов.

![перемещение](./assets/moving2.jpg)

Для перемещения используется команда *`git rebase <основная ветка> <тематическая ветка>`*, 
которая воспроизводит изменения тематической ветки на основной; HEAD тематической ветки указывает на последний воспроизведённый коммит.

## Перемещение vs. слияние
После слияния лог с историей может выглядеть довольно беспорядочно. С другой стороны, перемещение позволяет переписать историю в нормальной, последовательной форме.

Так зачем нужно слияние, если можно всё время пользоваться перемещением? К сожалению, перемещение не панацея от запутанных логов, 
так как перемещённые коммиты на самом деле отличаются от оригинальных, хотя и имеют одного и того же автора, сообщение и изменения.

Представим сценарий:

* В своей ветке вы создаёте несколько коммитов и сливаете их в мастер-ветку.
* Кто-то ещё решает поработать на основе ваших коммитов.
* Вы решаете переместить ваши коммиты и отправить их на сервер.
* Когда кто-то попытается слить свою работу на основе ваших изначальных коммитов, в итоге мы получим две параллельные ветки с одним автором, сообщениями и изменениями, но разными коммитами.  

Поэтому вот совет:

Перемещайте изменения только на вашей приватной локальной ветке — не перемещайте коммиты, от которых зависит ещё кто-то.

## Откат коммитов — revert и reset  

Похожие дебаты по поводу того, что лучше использовать, возникают, когда вы хотите откатить коммит. 
Команда *`git revert <коммит>`* создаёт новый коммит, отменяющий изменения, но сохраняющий историю, в то время как *`git reset <коммит>`* перемещает указатель HEAD, предоставляя более чистую историю (словно бы этого коммита никогда и не было). 
Важно отметить, что это также означает, что вы больше не сможете вернуться обратно к этим изменениям, например, если вы всё-таки решите, что отмена коммита была лишней. 
Чище — не значит лучше!